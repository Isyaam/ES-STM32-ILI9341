; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--cpp11 --list --debug -c --asm --interleave --exceptions --protect_stack -o.\out\debugv5\stm32f429_init.o --asm_dir=.\Lst\DebugV5\ --list_dir=.\Lst\DebugV5\ --depend=.\out\debugv5\stm32f429_init.d --cpu=Cortex-M4 --apcs=interwork --no_unaligned_access -O0 --diag_suppress=9931 -I.\Inc -I.\Inc\Debug -I.\Inc\Cortex -I.\Inc\Drivers -I.\Inc\Utilities -D__UVISION_VERSION=527 -DSTM32F429xx -DCORTEX_M=4 -DDEBUG --omf_browse=.\out\debugv5\stm32f429_init.crf --no_rtti STM32F429_init.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  VeryFirstInit PROC
;;;209    
;;;210    extern "C" void VeryFirstInit(void) noexcept
000000  b510              PUSH     {r4,lr}
;;;211    {
;;;212      Cortex::SetBASEPRI_privileged(PRIO_GRANULARITY);
000002  2010              MOVS     r0,#0x10
000004  f7fffffe          BL       _ZN6Cortex21SetBASEPRI_privilegedEj ; Cortex::SetBASEPRI_privileged(unsigned)
;;;213    
;;;214      AHBClockEnable(PERIPHERY_AHB_CCM);
000008  2014              MOVS     r0,#0x14
00000a  f7fffffe          BL       _Z14AHBClockEnablej ; AHBClockEnable(unsigned)
;;;215      AHBClockEnable(PERIPHERY_AHB_BKPSRAM); 
00000e  2012              MOVS     r0,#0x12
000010  f7fffffe          BL       _Z14AHBClockEnablej ; AHBClockEnable(unsigned)
;;;216      
;;;217      /// Enabling the FPU: 
;;;218      /// The FPU is disabled from reset. You must enable it before you can use any floating-point instructions. 
;;;219      /// The processor must be in privileged mode to read from and write to the CPACR.
;;;220      /// Set bits 20-23 to enable CP10 and CP11 coprocessors.
;;;221      // Die FPU muss bereits hier initialisiert werden, weil die FP-Lib zur Initialisierung bereits die FPU braucht 
;;;222      // (unabhängig davon, welches FPU-Modell man wählt, als auch bei fpu=none; klingt seltsam, ist aber so).
;;;223    
;;;224      Cortex::FpuEnable();
000014  f7fffffe          BL       _ZN6Cortex9FpuEnableEv ; Cortex::FpuEnable()
;;;225      
;;;226      ENABLE_CLOCK();
000018  f7fffffe          BL       _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f11EnableClockEv ; [local to STM32F429_init_cpp]::EnableClock()
;;;227      
;;;228      // HCLK = SYSCLK, PCLK1 = HCLK / 4 (low speed), PCLK2 = HCLK / 2 (high speed)
;;;229    
;;;230      rbRCC.CFGR = MASK_RCC_CFGR_HPRE_001 | MASK_RCC_CFGR_PPRE2_02 | MASK_RCC_CFGR_PPRE1_04;
00001c  f44f4014          MOV      r0,#0x9400
000020  49ad              LDR      r1,|L1.728|
000022  6088              STR      r0,[r1,#8]  ; rbRCC
;;;231    
;;;232      // Aktivierung des PLL mit Einstellung der gewünschten Takte-Quelle (HSI oder HSE).
;;;233    
;;;234      rbRCC.PLLCFGR = PLLSRC_VALUE
000024  48ad              LDR      r0,|L1.732|
000026  6048              STR      r0,[r1,#4]  ; rbRCC
;;;235      |               (PLL_M_VALUE << INDX_RCC_PLLCFGR_PLLM) 
;;;236      |               (PLL_N_VALUE << INDX_RCC_PLLCFGR_PLLN)
;;;237      |               (PLL_P_VALUE << INDX_RCC_PLLCFGR_PLLP)
;;;238      |               (PLL_Q_VALUE << INDX_RCC_PLLCFGR_PLLQ);
;;;239    
;;;240      ENABLE_SSCGR();
;;;241    
;;;242      // Warten, bis PLL stabil (ggf. wird ewig gewartet, wenn z.B. kein Quarz angeschlossen).
;;;243      
;;;244      do
000028  bf00              NOP      
                  |L1.42|
;;;245      {
;;;246        SET_REG_BIT(RCC, CR, PLLON); 
00002a  48ab              LDR      r0,|L1.728|
00002c  6800              LDR      r0,[r0,#0]  ; rbRCC
00002e  f0407080          ORR      r0,r0,#0x1000000
000032  49a9              LDR      r1,|L1.728|
000034  6008              STR      r0,[r1,#0]  ; rbRCC
;;;247      } while ( ! GET_REG_BIT(RCC, CR, PLLRDY) );
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]  ; rbRCC
00003a  f0007000          AND      r0,r0,#0x2000000
00003e  2800              CMP      r0,#0
000040  d0f3              BEQ      |L1.42|
;;;248    
;;;249      // Für die STM32F42x/STM32F43x-Prozessoren kann man hier den Over-drive aktivieren, um den Takt auf bis zu 180 MHz
;;;250      // zu erhöhen. Die STM32F40x/STM32F41x-Prozessoren gehen bis maximal 168 MHz.
;;;251      
;;;252      ENABLE_OVERDRIVE();
000042  f7fffffe          BL       _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f15EnableOverdriveEv ; [local to STM32F429_init_cpp]::EnableOverdrive()
;;;253      
;;;254      /// Bei einer Versorgungsspannung > 2,7 V und einem (einzustellenden) Systemtakt (HCLK) von > 150 MHz müssen 
;;;255      /// für den FLASH-Zugriff 5 WS eingestellt werden; zusätzlich auch Beschleuniger und Caches aktivieren.
;;;256      
;;;257      rbFLASH.ACR = MASK_FLASH_ACR_PRFTEN | MASK_FLASH_ACR_ICEN | MASK_FLASH_ACR_DCEN | MASK_FLASH_ACR_LATENCY_5WS;
000046  f2407005          MOV      r0,#0x705
00004a  49a5              LDR      r1,|L1.736|
00004c  6008              STR      r0,[r1,#0]  ; rbFLASH
;;;258      
;;;259      // Nachfolgend wird der Systemtakt vom PLL übernommen.
;;;260      
;;;261      do
00004e  bf00              NOP      
                  |L1.80|
;;;262      {
;;;263        SET_REG_BIT(RCC, CFGR, SW_PLL);
000050  48a1              LDR      r0,|L1.728|
000052  6880              LDR      r0,[r0,#8]  ; rbRCC
000054  f0400002          ORR      r0,r0,#2
000058  499f              LDR      r1,|L1.728|
00005a  6088              STR      r0,[r1,#8]  ; rbRCC
;;;264      } while ( (rbRCC.CFGR & MASK_RCC_CFGR_SWS) != MASK_RCC_CFGR_SWS_PLL );
00005c  4608              MOV      r0,r1
00005e  6880              LDR      r0,[r0,#8]  ; rbRCC
000060  f000000c          AND      r0,r0,#0xc
000064  2808              CMP      r0,#8
000066  d1f3              BNE      |L1.80|
;;;265    
;;;266      rbSCB.VTOR = IROM1_START;
000068  0600              LSLS     r0,r0,#24
00006a  499e              LDR      r1,|L1.740|
00006c  6088              STR      r0,[r1,#8]  ; rbSCB
;;;267    
;;;268      rbRCC.PLLSAICFGR = 
00006e  489e              LDR      r0,|L1.744|
000070  4999              LDR      r1,|L1.728|
000072  f8c10088          STR      r0,[r1,#0x88]  ; rbRCC
;;;269      ((__PLLSAI_OUTPUT /          CLK_VCO_I_MHZ) << INDX_RCC_PLLSAICFGR_PLLSAIN) | // VCO-Output
;;;270      (                                        7U << INDX_RCC_PLLSAICFGR_PLLSAIQ) | 
;;;271      ((__PLLSAI_OUTPUT / __PLLSAI_LCD_TFT_CLOCK) << INDX_RCC_PLLSAICFGR_PLLSAIR);  // LCD-Clock = VCO-Output / PLLSAIR
;;;272    
;;;273      rbRCC.DCKCFGR = (rbRCC.DCKCFGR & ~MASK_RCC_DCKCFGR_PLLSAIDIVR) | 
000076  4608              MOV      r0,r1
000078  f8d0008c          LDR      r0,[r0,#0x8c]  ; rbRCC
00007c  f4203040          BIC      r0,r0,#0x30000
000080  f4403000          ORR      r0,r0,#0x20000
000084  f8c1008c          STR      r0,[r1,#0x8c]  ; rbRCC
;;;274      (__PLLSAI_DOTCLK_DIV << INDX_RCC_DCKCFGR_PLLSAIDIVR);
;;;275    
;;;276      do
000088  bf00              NOP      
                  |L1.138|
;;;277      {
;;;278        SET_REG_BIT(RCC, CR, PLLSAION); 
00008a  4893              LDR      r0,|L1.728|
00008c  6800              LDR      r0,[r0,#0]  ; rbRCC
00008e  f0405080          ORR      r0,r0,#0x10000000
000092  4991              LDR      r1,|L1.728|
000094  6008              STR      r0,[r1,#0]  ; rbRCC
;;;279      } while ( ! GET_REG_BIT(RCC, CR, PLLSAIRDY) ); 
000096  4608              MOV      r0,r1
000098  6800              LDR      r0,[r0,#0]  ; rbRCC
00009a  f0005000          AND      r0,r0,#0x20000000
00009e  2800              CMP      r0,#0
0000a0  d0f3              BEQ      |L1.138|
;;;280      
;;;281      InitSDRAM();
0000a2  f7fffffe          BL       _Z9InitSDRAMv ; InitSDRAM()
;;;282    }
0000a6  bd10              POP      {r4,pc}
;;;283    
                          ENDP

                  _Z4HClkv PROC ; HClk()
;;;284    unsigned HClk() noexcept
0000a8  488b              LDR      r0,|L1.728|
;;;285    {
;;;286      switch(rbRCC.CFGR & MASK_RCC_CFGR_HPRE)
0000aa  6880              LDR      r0,[r0,#8]  ; rbRCC
0000ac  f00000f0          AND      r0,r0,#0xf0
0000b0  f000010f          AND      r1,r0,#0xf
0000b4  b949              CBNZ     r1,|L1.202|
0000b6  1100              ASRS     r0,r0,#4
0000b8  3808              SUBS     r0,r0,#8
0000ba  2808              CMP      r0,#8
0000bc  d205              BCS      |L1.202|
0000be  e8dff000          TBB      [pc,r0]
0000c2  0608              DCB      0x06,0x08
0000c4  0a0c0e10          DCB      0x0a,0x0c,0x0e,0x10
0000c8  1214              DCB      0x12,0x14
                  |L1.202|
;;;287      {
;;;288        default:                     return SYSCLK;
0000ca  4888              LDR      r0,|L1.748|
                  |L1.204|
;;;289        case MASK_RCC_CFGR_HPRE_002: return SYSCLK /   2U;
;;;290        case MASK_RCC_CFGR_HPRE_004: return SYSCLK /   4U;
;;;291        case MASK_RCC_CFGR_HPRE_008: return SYSCLK /   8U;
;;;292        case MASK_RCC_CFGR_HPRE_016: return SYSCLK /  16U;
;;;293        case MASK_RCC_CFGR_HPRE_064: return SYSCLK /  64U;
;;;294        case MASK_RCC_CFGR_HPRE_128: return SYSCLK / 128U;
;;;295        case MASK_RCC_CFGR_HPRE_256: return SYSCLK / 256U;
;;;296        case MASK_RCC_CFGR_HPRE_512: return SYSCLK / 512U;
;;;297      }
;;;298    }
0000cc  4770              BX       lr
0000ce  4888              LDR      r0,|L1.752|
0000d0  e7fc              B        |L1.204|
0000d2  4888              LDR      r0,|L1.756|
0000d4  e7fa              B        |L1.204|
0000d6  4888              LDR      r0,|L1.760|
0000d8  e7f8              B        |L1.204|
0000da  4888              LDR      r0,|L1.764|
0000dc  e7f6              B        |L1.204|
0000de  4888              LDR      r0,|L1.768|
0000e0  e7f4              B        |L1.204|
0000e2  4888              LDR      r0,|L1.772|
0000e4  e7f2              B        |L1.204|
0000e6  4888              LDR      r0,|L1.776|
0000e8  e7f0              B        |L1.204|
0000ea  4888              LDR      r0,|L1.780|
0000ec  e7ee              B        |L1.204|
;;;299    
                          ENDP

                  _Z5PClk1v PROC ; PClk1()
;;;300    unsigned PClk1() noexcept
0000ee  b570              PUSH     {r4-r6,lr}
;;;301    {
;;;302      auto const hclk = HClk();
0000f0  f7fffffe          BL       _Z4HClkv ; HClk()
0000f4  4602              MOV      r2,r0
;;;303      
;;;304      switch(rbRCC.CFGR & MASK_RCC_CFGR_PPRE1)
0000f6  4878              LDR      r0,|L1.728|
0000f8  6880              LDR      r0,[r0,#8]  ; rbRCC
0000fa  f40050e0          AND      r0,r0,#0x1c00
0000fe  f5b05f80          CMP      r0,#0x1000
000102  d00b              BEQ      |L1.284|
000104  f5b05fa0          CMP      r0,#0x1400
000108  d00b              BEQ      |L1.290|
00010a  f5b05fc0          CMP      r0,#0x1800
00010e  d00b              BEQ      |L1.296|
000110  f5b05fe0          CMP      r0,#0x1c00
000114  d00b              BEQ      |L1.302|
;;;305      {
;;;306        default:                     return hclk;
000116  4611              MOV      r1,r2
000118  4608              MOV      r0,r1
                  |L1.282|
;;;307        case MASK_RCC_CFGR_PPRE1_02: return hclk /  2U;
;;;308        case MASK_RCC_CFGR_PPRE1_04: return hclk /  4U;
;;;309        case MASK_RCC_CFGR_PPRE1_08: return hclk /  8U;
;;;310        case MASK_RCC_CFGR_PPRE1_16: return hclk / 16U;
;;;311      }
;;;312    }
00011a  bd70              POP      {r4-r6,pc}
                  |L1.284|
00011c  0853              LSRS     r3,r2,#1              ;307
00011e  4618              MOV      r0,r3                 ;307
000120  e7fb              B        |L1.282|
                  |L1.290|
000122  0894              LSRS     r4,r2,#2              ;308
000124  4620              MOV      r0,r4                 ;308
000126  e7f8              B        |L1.282|
                  |L1.296|
000128  08d5              LSRS     r5,r2,#3              ;309
00012a  4628              MOV      r0,r5                 ;309
00012c  e7f5              B        |L1.282|
                  |L1.302|
00012e  0910              LSRS     r0,r2,#4              ;310
000130  bf00              NOP                            ;310
000132  e7f2              B        |L1.282|
;;;313        
                          ENDP

                  _Z5PClk2v PROC ; PClk2()
;;;314    unsigned PClk2() noexcept
000134  b570              PUSH     {r4-r6,lr}
;;;315    {
;;;316      auto const hclk = HClk();
000136  f7fffffe          BL       _Z4HClkv ; HClk()
00013a  4602              MOV      r2,r0
;;;317      
;;;318      switch(rbRCC.CFGR & MASK_RCC_CFGR_PPRE2)
00013c  4866              LDR      r0,|L1.728|
00013e  6880              LDR      r0,[r0,#8]  ; rbRCC
000140  f4004060          AND      r0,r0,#0xe000
000144  f5b04f00          CMP      r0,#0x8000
000148  d00b              BEQ      |L1.354|
00014a  f5b04f20          CMP      r0,#0xa000
00014e  d00b              BEQ      |L1.360|
000150  f5b04f40          CMP      r0,#0xc000
000154  d00b              BEQ      |L1.366|
000156  f5b04f60          CMP      r0,#0xe000
00015a  d00b              BEQ      |L1.372|
;;;319      {
;;;320        default:                     return hclk;
00015c  4611              MOV      r1,r2
00015e  4608              MOV      r0,r1
                  |L1.352|
;;;321        case MASK_RCC_CFGR_PPRE2_02: return hclk /  2U;
;;;322        case MASK_RCC_CFGR_PPRE2_04: return hclk /  4U;
;;;323        case MASK_RCC_CFGR_PPRE2_08: return hclk /  8U;
;;;324        case MASK_RCC_CFGR_PPRE2_16: return hclk / 16U;
;;;325      }
;;;326    }
000160  bd70              POP      {r4-r6,pc}
                  |L1.354|
000162  0853              LSRS     r3,r2,#1              ;321
000164  4618              MOV      r0,r3                 ;321
000166  e7fb              B        |L1.352|
                  |L1.360|
000168  0894              LSRS     r4,r2,#2              ;322
00016a  4620              MOV      r0,r4                 ;322
00016c  e7f8              B        |L1.352|
                  |L1.366|
00016e  08d5              LSRS     r5,r2,#3              ;323
000170  4628              MOV      r0,r5                 ;323
000172  e7f5              B        |L1.352|
                  |L1.372|
000174  0910              LSRS     r0,r2,#4              ;324
000176  bf00              NOP                            ;324
000178  e7f2              B        |L1.352|
;;;327        
                          ENDP

                  _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f9LocalInitEv PROC ; [local to STM32F429_init_cpp]::LocalInit()
;;;393    
;;;394    static __attribute__((constructor(102))) void LocalInit(void) noexcept 
00017a  b510              PUSH     {r4,lr}
;;;395    {
;;;396      // Diese Funktion wird durch die Laufzeitumgebung (RTE) nach Initialisierung der RTE jedoch noch vor Aufruf von main() aufgerufen.
;;;397    
;;;398      Cortex::SetPRIMASK_privileged();
00017c  f7fffffe          BL       _ZN6Cortex21SetPRIMASK_privilegedEv ; Cortex::SetPRIMASK_privileged()
;;;399    
;;;400      rbMPU.RNR  = 0;
000180  2000              MOVS     r0,#0
000182  4963              LDR      r1,|L1.784|
000184  6088              STR      r0,[r1,#8]  ; rbMPU
;;;401      rbMPU.RBAR = IROM1_START;
000186  f04f6000          MOV      r0,#0x8000000
00018a  60c8              STR      r0,[r1,#0xc]  ; rbMPU
;;;402      rbMPU.RASR = MASK_MPU_RASR_ENABLE | MASK_MPU_RASR_SIZE_001MB | MASK_MPU_RASR_C                   | MASK_MPU_RASR_AP_RW_RO;
00018c  4861              LDR      r0,|L1.788|
00018e  6108              STR      r0,[r1,#0x10]  ; rbMPU
;;;403    
;;;404      rbMPU.RNR  = 1;
000190  2001              MOVS     r0,#1
000192  6088              STR      r0,[r1,#8]  ; rbMPU
;;;405      rbMPU.RBAR = IRAM1_START;
000194  0740              LSLS     r0,r0,#29
000196  60c8              STR      r0,[r1,#0xc]  ; rbMPU
;;;406      rbMPU.RASR = MASK_MPU_RASR_ENABLE | MASK_MPU_RASR_SIZE_128KB | MASK_MPU_RASR_C | MASK_MPU_RASR_S | MASK_MPU_RASR_AP_RW_RW | MASK_MPU_RASR_XN;
000198  485f              LDR      r0,|L1.792|
00019a  6108              STR      r0,[r1,#0x10]  ; rbMPU
;;;407    
;;;408      rbMPU.RNR  = 2;
00019c  2002              MOVS     r0,#2
00019e  6088              STR      r0,[r1,#8]  ; rbMPU
;;;409      rbMPU.RBAR = IRAM2_START;
0001a0  06c0              LSLS     r0,r0,#27
0001a2  60c8              STR      r0,[r1,#0xc]  ; rbMPU
;;;410      rbMPU.RASR = MASK_MPU_RASR_ENABLE | MASK_MPU_RASR_SIZE_064KB | MASK_MPU_RASR_C | MASK_MPU_RASR_B | MASK_MPU_RASR_AP_RW_RW | MASK_MPU_RASR_XN;
0001a4  485d              LDR      r0,|L1.796|
0001a6  6108              STR      r0,[r1,#0x10]  ; rbMPU
;;;411    
;;;412      // Achtung: 'Bit band alias' (Cortex-M4) liegt im Bereich 0x42000000 bis 0x43FFFFFF (32 MB)
;;;413      // Peripherie (ab 0x40000000) muss dehalb mindestens 64 MB umfassen.
;;;414      // Wenn AHB2 verwendet werden soll, dann sogar entsprechend mehr.
;;;415      // Der Cortex-M7 hat aus Performance-Gründen kein bit banding mehr!
;;;416      
;;;417      rbMPU.RNR  = 3;
0001a8  2003              MOVS     r0,#3
0001aa  6088              STR      r0,[r1,#8]  ; rbMPU
;;;418      rbMPU.RBAR = 0x40000000U;
0001ac  f04f4080          MOV      r0,#0x40000000
0001b0  60c8              STR      r0,[r1,#0xc]  ; rbMPU
;;;419      rbMPU.RASR = MASK_MPU_RASR_ENABLE | MASK_MPU_RASR_SIZE_512MB | MASK_MPU_RASR_B | MASK_MPU_RASR_S | MASK_MPU_RASR_AP_RW_RW | MASK_MPU_RASR_XN;
0001b2  485b              LDR      r0,|L1.800|
0001b4  6108              STR      r0,[r1,#0x10]  ; rbMPU
;;;420      
;;;421      // SDRAM ab 0xD0000000, 8 MB
;;;422      
;;;423      rbMPU.RNR  = 4;
0001b6  2004              MOVS     r0,#4
0001b8  6088              STR      r0,[r1,#8]  ; rbMPU
;;;424      rbMPU.RBAR = 0xD0000000U;
0001ba  f04f4050          MOV      r0,#0xd0000000
0001be  60c8              STR      r0,[r1,#0xc]  ; rbMPU
;;;425      rbMPU.RASR = MASK_MPU_RASR_ENABLE | MASK_MPU_RASR_SIZE_008MB | MASK_MPU_RASR_C | MASK_MPU_RASR_S | MASK_MPU_RASR_AP_RW_RW | MASK_MPU_RASR_XN;
0001c0  4855              LDR      r0,|L1.792|
0001c2  300c              ADDS     r0,r0,#0xc
0001c4  6108              STR      r0,[r1,#0x10]  ; rbMPU
;;;426      
;;;427      // PBP ab 0xE0000000
;;;428      // Nachfolgende Einstellung funktioniert noch nicht richtig. Sinn dieser Maßnahme wäre es, auf die SCB-Register auch im 
;;;429      // nicht-privilegierten zugreifen zu können. Es ist jedoch fraglich, ob das überhaupt einstellbar ist.
;;;430    
;;;431      rbMPU.RNR  = 5; 
0001c6  2005              MOVS     r0,#5
0001c8  6088              STR      r0,[r1,#8]  ; rbMPU
;;;432      rbMPU.RBAR = 0xE0000000U;
0001ca  f04f4060          MOV      r0,#0xe0000000
0001ce  60c8              STR      r0,[r1,#0xc]  ; rbMPU
;;;433      rbMPU.RASR = MASK_MPU_RASR_ENABLE | MASK_MPU_RASR_SIZE_001MB | MASK_MPU_RASR_AP_RW_RW | MASK_MPU_RASR_XN; 
0001d0  4854              LDR      r0,|L1.804|
0001d2  6108              STR      r0,[r1,#0x10]  ; rbMPU
;;;434      
;;;435      rbMPU.CTRL = MASK_MPU_CTRL_ENABLE;
0001d4  2001              MOVS     r0,#1
0001d6  6048              STR      r0,[r1,#4]  ; rbMPU
;;;436    
;;;437      Cortex::DSB();
0001d8  f7fffffe          BL       _ZN6Cortex3DSBEv ; Cortex::DSB()
;;;438      Cortex::ISB();
0001dc  f7fffffe          BL       _ZN6Cortex3ISBEv ; Cortex::ISB()
;;;439        
;;;440    	static WORD stack[0x4000 / sizeof(WORD)] __attribute__((section("CCM")));
;;;441    
;;;442      Cortex::SwitchStack(stack);
0001e0  4851              LDR      r0,|L1.808|
0001e2  f7fffffe          BL       _ZN6Cortex11SwitchStackILj4096EEEvRAT__j ; void Cortex::SwitchStack<(unsigned)4096>(unsigned(&)[T1])
;;;443    
;;;444      Init_SCB_VTOR();
;;;445      Init_SCB_FAULTS();
0001e6  f7fffffe          BL       _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f15Init_SCB_FAULTSEv ; [local to STM32F429_init_cpp]::Init_SCB_FAULTS()
;;;446      Init_STK();
0001ea  f7fffffe          BL       _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f8Init_STKEv ; [local to STM32F429_init_cpp]::Init_STK()
;;;447      Init_IWDG();
;;;448    
;;;449      // Prioritäten der wichtigsten Core-IRQs einstellen. 
;;;450      
;;;451      rbSCB.SHPR[SCB_SHPR_MEM_FLT] = PRIO_GRANULARITY *  0U;
0001ee  2000              MOVS     r0,#0
0001f0  493c              LDR      r1,|L1.740|
0001f2  7608              STRB     r0,[r1,#0x18]
;;;452      rbSCB.SHPR[SCB_SHPR_BUS_FLT] = PRIO_GRANULARITY *  0U;
0001f4  2100              MOVS     r1,#0
0001f6  483b              LDR      r0,|L1.740|
0001f8  7641              STRB     r1,[r0,#0x19]
;;;453      rbSCB.SHPR[SCB_SHPR_MEM_FLT] = PRIO_GRANULARITY *  0U;
0001fa  2000              MOVS     r0,#0
0001fc  4939              LDR      r1,|L1.740|
0001fe  7608              STRB     r0,[r1,#0x18]
;;;454      rbSCB.SHPR[SCB_SHPR_SVC    ] = PRIO_GRANULARITY *  1U;
000200  2110              MOVS     r1,#0x10
000202  4838              LDR      r0,|L1.740|
000204  77c1              STRB     r1,[r0,#0x1f]
;;;455      rbSCB.SHPR[SCB_SHPR_PSV    ] = PRIO_GRANULARITY * 15U;
000206  21f0              MOVS     r1,#0xf0
000208  f8801022          STRB     r1,[r0,#0x22]
;;;456      rbSCB.SHPR[SCB_SHPR_STK    ] = __SCB_SHPR_PRI15; 
00020c  2130              MOVS     r1,#0x30
00020e  f8801023          STRB     r1,[r0,#0x23]
;;;457    
;;;458      Cortex::SetBASEPRI_privileged(Cortex::GetMinPrio());
000212  f7fffffe          BL       _ZN6Cortex10GetMinPrioEv ; Cortex::GetMinPrio()
000216  4604              MOV      r4,r0
000218  f7fffffe          BL       _ZN6Cortex21SetBASEPRI_privilegedEj ; Cortex::SetBASEPRI_privileged(unsigned)
;;;459      Cortex::ClrPRIMASK_privileged();
00021c  f7fffffe          BL       _ZN6Cortex21ClrPRIMASK_privilegedEv ; Cortex::ClrPRIMASK_privileged()
;;;460    }
000220  bd10              POP      {r4,pc}
;;;461    
                          ENDP

                  UndefinedIRQ PROC
;;;462    extern "C" void UndefinedIRQ(void)
000222  b510              PUSH     {r4,lr}
;;;463    {
;;;464      DEBUG_BREAK(1); 
000224  be01              BKPT     #1
;;;465    
;;;466      for ( ;; ) 
000226  bf00              NOP      
;;;467      {
;;;468        Cortex::Reset();
000228  f7fffffe          BL       _ZN6Cortex5ResetEv ; Cortex::Reset()
;;;469      }
;;;470    }
;;;471    
                          ENDP

                  HandleSVC PROC
;;;472    extern "C" __weak void HandleSVC   (WORD *) { for ( ;; ) DEBUG_BREAK(1); }
00022c  bf00              NOP      
                  |L1.558|
00022e  be01              BKPT     #1
000230  e7fd              B        |L1.558|
;;;473    
                          ENDP

                  HandleHrdFlt PROC
;;;474    extern "C" __weak void HandleHrdFlt(WORD *) { for ( ;; ) DEBUG_BREAK(1); }
000232  bf00              NOP      
                  |L1.564|
000234  be01              BKPT     #1
000236  e7fd              B        |L1.564|
;;;475    extern "C" __weak void HandleUsgFlt(WORD *) { for ( ;; ) DEBUG_BREAK(1); }
                          ENDP

                  HandleUsgFlt PROC
000238  bf00              NOP      
                  |L1.570|
00023a  be01              BKPT     #1
00023c  e7fd              B        |L1.570|
;;;476    extern "C" __weak void HandleBusFlt(WORD *) { for ( ;; ) DEBUG_BREAK(1); }
                          ENDP

                  HandleBusFlt PROC
00023e  bf00              NOP      
                  |L1.576|
000240  be01              BKPT     #1
000242  e7fd              B        |L1.576|
;;;477    extern "C" __weak void HandleMemFlt(WORD *) { for ( ;; ) DEBUG_BREAK(1); }
                          ENDP

                  HandleMemFlt PROC
000244  bf00              NOP      
                  |L1.582|
000246  be01              BKPT     #1
000248  e7fd              B        |L1.582|
                          ENDP

                  _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f11EnableClockEv PROC ; [local to STM32F429_init_cpp]::EnableClock()
;;;133    /// HSE-Takt aktivieren und warten, bis der Takt gültig ist.
;;;134    static inline void EnableClock() noexcept
00024a  bf00              NOP      
                  |L1.588|
;;;135    {
;;;136      do
;;;137      {
;;;138        SET_REG_BIT(RCC, CR, HSEON);
00024c  4822              LDR      r0,|L1.728|
00024e  6800              LDR      r0,[r0,#0]  ; rbRCC
000250  f4403080          ORR      r0,r0,#0x10000
000254  4920              LDR      r1,|L1.728|
000256  6008              STR      r0,[r1,#0]  ; rbRCC
;;;139      } while ( ! GET_REG_BIT(RCC, CR, HSERDY) );
000258  4608              MOV      r0,r1
00025a  6800              LDR      r0,[r0,#0]  ; rbRCC
00025c  f4003000          AND      r0,r0,#0x20000
000260  2800              CMP      r0,#0
000262  d0f3              BEQ      |L1.588|
;;;140    }
000264  4770              BX       lr
;;;141    
                          ENDP

                  _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f15EnableOverdriveEv PROC ; [local to STM32F429_init_cpp]::EnableOverdrive()
;;;148    
;;;149    static inline void EnableOverdrive() noexcept
000266  b510              PUSH     {r4,lr}
;;;150    {
;;;151      APBClockEnable(PERIPHERY_APB_PWR);
000268  201c              MOVS     r0,#0x1c
00026a  f7fffffe          BL       _Z14APBClockEnablej ; APBClockEnable(unsigned)
;;;152    
;;;153      do
00026e  bf00              NOP      
                  |L1.624|
;;;154      {
;;;155        SET_REG_BIT(PWR, CR, ODEN);
000270  482e              LDR      r0,|L1.812|
000272  6800              LDR      r0,[r0,#0]  ; rbPWR
000274  f4403080          ORR      r0,r0,#0x10000
000278  492c              LDR      r1,|L1.812|
00027a  6008              STR      r0,[r1,#0]  ; rbPWR
;;;156      } while ( ! GET_REG_BIT(PWR, CSR, ODRDY) );
00027c  4608              MOV      r0,r1
00027e  6840              LDR      r0,[r0,#4]  ; rbPWR
000280  f4003080          AND      r0,r0,#0x10000
000284  2800              CMP      r0,#0
000286  d0f3              BEQ      |L1.624|
;;;157    
;;;158      do
000288  bf00              NOP      
                  |L1.650|
;;;159      {
;;;160        SET_REG_BIT(PWR, CR, ODSWEN);
00028a  4828              LDR      r0,|L1.812|
00028c  6800              LDR      r0,[r0,#0]  ; rbPWR
00028e  f4403000          ORR      r0,r0,#0x20000
000292  4926              LDR      r1,|L1.812|
000294  6008              STR      r0,[r1,#0]  ; rbPWR
;;;161      } while ( ! GET_REG_BIT(PWR, CSR, ODSWRDY) );
000296  4608              MOV      r0,r1
000298  6840              LDR      r0,[r0,#4]  ; rbPWR
00029a  f4003000          AND      r0,r0,#0x20000
00029e  2800              CMP      r0,#0
0002a0  d0f3              BEQ      |L1.650|
;;;162    }
0002a2  bd10              POP      {r4,pc}
;;;163    
                          ENDP

                  _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f8Init_STKEv PROC ; [local to STM32F429_init_cpp]::Init_STK()
;;;337    
;;;338    static inline void Init_STK() noexcept
0002a4  b500              PUSH     {lr}
;;;339    {
;;;340      unsigned const clock = STK_CLK();
0002a6  f7fffffe          BL       _Z4HClkv ; HClk()
0002aa  4602              MOV      r2,r0
;;;341    
;;;342      rbSTK.CSR = 0U;
0002ac  2000              MOVS     r0,#0
0002ae  4920              LDR      r1,|L1.816|
0002b0  6008              STR      r0,[r1,#0]  ; rbSTK
;;;343      rbSTK.RVR = ((__STK_PERIOD * clock) / 1000U) - 1U;
0002b2  f44f707a          MOV      r0,#0x3e8
0002b6  fbb2f0f0          UDIV     r0,r2,r0
0002ba  1e40              SUBS     r0,r0,#1
0002bc  6048              STR      r0,[r1,#4]  ; rbSTK
;;;344      rbSTK.CVR = 0U; 
0002be  2000              MOVS     r0,#0
0002c0  6088              STR      r0,[r1,#8]  ; rbSTK
;;;345      rbSTK.CSR = __STK_CTRL_VAL | MASK_STK_CTRL_ENABLE; // don't forget to enable the counter
0002c2  2007              MOVS     r0,#7
0002c4  6008              STR      r0,[r1,#0]  ; rbSTK
;;;346    }
0002c6  bd00              POP      {pc}
;;;347    
                          ENDP

                  _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f15Init_SCB_FAULTSEv PROC ; [local to STM32F429_init_cpp]::Init_SCB_FAULTS()
;;;383    
;;;384    static inline void Init_SCB_FAULTS() noexcept
0002c8  f44f20e0          MOV      r0,#0x70000
;;;385    {
;;;386      rbSCB.SHCSR = __SCB_SHCSR;
0002cc  4905              LDR      r1,|L1.740|
0002ce  6248              STR      r0,[r1,#0x24]  ; rbSCB
;;;387      rbSCB.CCR = __SCB_CCR;
0002d0  f240201a          MOV      r0,#0x21a
0002d4  6148              STR      r0,[r1,#0x14]  ; rbSCB
;;;388    }
0002d6  4770              BX       lr
;;;389    
                          ENDP

                  |L1.728|
                          DCD      rbRCC
                  |L1.732|
                          DCD      0x07401682
                  |L1.736|
                          DCD      rbFLASH
                  |L1.740|
                          DCD      rbSCB
                  |L1.744|
                          DCD      0x47000c00
                  |L1.748|
                          DCD      0x0aba9500
                  |L1.752|
                          DCD      0x055d4a80
                  |L1.756|
                          DCD      0x02aea540
                  |L1.760|
                          DCD      0x015752a0
                  |L1.764|
                          DCD      0x00aba950
                  |L1.768|
                          DCD      0x002aea54
                  |L1.772|
                          DCD      0x0015752a
                  |L1.776|
                          DCD      0x000aba95
                  |L1.780|
                          DCD      0x00055d4a
                  |L1.784|
                          DCD      rbMPU
                  |L1.788|
                          DCD      0x02020027
                  |L1.792|
                          DCD      0x13060021
                  |L1.796|
                          DCD      0x1303001f
                  |L1.800|
                          DCD      0x13050039
                  |L1.804|
                          DCD      0x13000027
                  |L1.808|
                          DCD      _ZZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f9LocalInitEvE5stack ; [local to STM32F429_init_cpp]::LocalInit()::stack
                  |L1.812|
                          DCD      rbPWR
                  |L1.816|
                          DCD      rbSTK

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.init_array.00102||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000 ; [local to STM32F429_init_cpp]::LocalInit()
                          RELOC 38, _ZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f9LocalInitEv

                          AREA ||CCM||, DATA, ALIGN=2

                  _ZZN40_INTERNAL_18_STM32F429_init_cpp_65c55d7f9LocalInitEvE5stack ; [local to STM32F429_init_cpp]::LocalInit()::stack
                          %        16384

                          AREA ||i._Z14AHBClockEnablej||, COMGROUP=_Z14AHBClockEnablej, CODE, READONLY, ALIGN=2

                  _Z14AHBClockEnablej PROC ; AHBClockEnable(unsigned)
;;;332    /// \param[in] num kennzeichnet die AHB-Periphery.
;;;333    inline void AHBClockEnable(WORD const num) noexcept
000000  b570              PUSH     {r4-r6,lr}
;;;334    {
000002  4604              MOV      r4,r0
;;;335      auto const i = num >> PERIPHERY_INDX_POS;
000004  0a25              LSRS     r5,r4,#8
;;;336      auto const n = num % 32U;
000006  f004061f          AND      r6,r4,#0x1f
;;;337      
;;;338      Atomic::Orr(rbRCC.AHBENR[i], 1U << n);
00000a  2201              MOVS     r2,#1
00000c  fa02f106          LSL      r1,r2,r6
000010  4a02              LDR      r2,|L16.28|
000012  eb020085          ADD      r0,r2,r5,LSL #2
000016  f7fffffe          BL       _ZN6Atomic3OrrIjEET_RVS1_S1_ ; T1 Atomic::Orr<unsigned>(volatile T1&, T1)
;;;339    }
00001a  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

                  |L16.28|
                          DCD      rbRCC+0x30

                          AREA ||area_number.17||, COMGROUP=_Z14AHBClockEnablej, LINKORDER=||i._Z14AHBClockEnablej||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z14AHBClockEnablej||
                          DCD      0x00000001

                          AREA ||i._ZN6Cortex3DSBEv||, COMGROUP=_ZN6Cortex3DSBEv, CODE, READONLY, ALIGN=1

                  _ZN6Cortex3DSBEv PROC ; Cortex::DSB()
;;;122      FORCE_INLINE void DMB() noexcept { SCHEDULE_BARRIER(); __dmb(0xF); SCHEDULE_BARRIER(); }  
;;;123      FORCE_INLINE void DSB() noexcept { SCHEDULE_BARRIER(); __dsb(0xF); SCHEDULE_BARRIER(); }
000000  bf00              NOP      
000002  bf00              NOP      
000004  f3bf8f4f          DSB      
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  4770              BX       lr
;;;124      FORCE_INLINE void ISB() noexcept { SCHEDULE_BARRIER(); __isb(0xF); SCHEDULE_BARRIER(); }
                          ENDP


                          AREA ||area_number.25||, COMGROUP=_ZN6Cortex3DSBEv, LINKORDER=||i._ZN6Cortex3DSBEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6Cortex3DSBEv||
                          DCD      0x00000001

                          AREA ||t._ZN6Atomic3OrrIjEET_RVS1_S1_||, COMGROUP=_ZN6Atomic3OrrIjEET_RVS1_S1_, CODE, READONLY, ALIGN=1

                  _ZN6Atomic3OrrIjEET_RVS1_S1_ PROC ; T1 Atomic::Orr<unsigned>(volatile T1&, T1)
;;;182      /// \tparam TYPE ist der Datentyp der atomaren Operation.
;;;183      template<typename TYPE> inline TYPE Orr(TYPE volatile & data, TYPE const mask ) noexcept { return Modify<TYPE, BinOpType::opOrr>(data, mask); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZN6Atomic6ModifyIjLNS_9BinOpTypeE5EEET_RVS2_S2_ ; T1 Atomic::Modify<unsigned, (Atomic::BinOpType)5>(volatile T1&, T1)
00000e  4606              MOV      r6,r0
000010  4630              MOV      r0,r6
000012  bd70              POP      {r4-r6,pc}
;;;184    
                          ENDP


                          AREA ||area_number.32||, COMGROUP=_ZN6Atomic3OrrIjEET_RVS1_S1_, LINKORDER=||t._ZN6Atomic3OrrIjEET_RVS1_S1_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN6Atomic3OrrIjEET_RVS1_S1_||
                          DCD      0x00000001

                          AREA ||i._Z14APBClockEnablej||, COMGROUP=_Z14APBClockEnablej, CODE, READONLY, ALIGN=2

                  _Z14APBClockEnablej PROC ; APBClockEnable(unsigned)
;;;342    /// \param[in] num kennzeichnet die APB-Periphery.
;;;343    inline void APBClockEnable(WORD const num) noexcept
000000  b570              PUSH     {r4-r6,lr}
;;;344    {
000002  4604              MOV      r4,r0
;;;345      auto const i = num >> PERIPHERY_INDX_POS;
000004  0a25              LSRS     r5,r4,#8
;;;346      auto const n = num % 32U;
000006  f004061f          AND      r6,r4,#0x1f
;;;347      
;;;348      Atomic::Orr(rbRCC.APBENR[i], 1U << n);
00000a  2201              MOVS     r2,#1
00000c  fa02f106          LSL      r1,r2,r6
000010  4a02              LDR      r2,|L38.28|
000012  eb020085          ADD      r0,r2,r5,LSL #2
000016  f7fffffe          BL       _ZN6Atomic3OrrIjEET_RVS1_S1_ ; T1 Atomic::Orr<unsigned>(volatile T1&, T1)
;;;349    }
00001a  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP

                  |L38.28|
                          DCD      rbRCC+0x40

                          AREA ||area_number.39||, COMGROUP=_Z14APBClockEnablej, LINKORDER=||i._Z14APBClockEnablej||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z14APBClockEnablej||
                          DCD      0x00000001

                          AREA ||i._ZN6Cortex21SetBASEPRI_privilegedEj||, COMGROUP=_ZN6Cortex21SetBASEPRI_privilegedEj, CODE, READONLY, ALIGN=1

                  _ZN6Cortex21SetBASEPRI_privilegedEj PROC ; Cortex::SetBASEPRI_privileged(unsigned)
;;;174    
;;;175      FORCE_INLINE void SetBASEPRI_privileged(WORD const value) noexcept { ARM_WSR(basepri, value); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       _Z15ARM_WSR_baseprij ; ARM_WSR_basepri(unsigned)
00000a  bd10              POP      {r4,pc}
;;;176    
                          ENDP


                          AREA ||area_number.46||, COMGROUP=_ZN6Cortex21SetBASEPRI_privilegedEj, LINKORDER=||i._ZN6Cortex21SetBASEPRI_privilegedEj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6Cortex21SetBASEPRI_privilegedEj||
                          DCD      0x00000001

                          AREA ||t._ZN6Cortex11SwitchStackILj4096EEEvRAT__j||, COMGROUP=_ZN6Cortex11SwitchStackILj4096EEEvRAT__j, CODE, READONLY, ALIGN=1

                  _ZN6Cortex11SwitchStackILj4096EEEvRAT__j PROC ; void Cortex::SwitchStack<(unsigned)4096>(unsigned(&)[T1])
;;;317      template<unsigned DIM>
;;;318      FORCE_INLINE void SwitchStack(WORD (& stack)[DIM]) noexcept { return SwitchStack(stack, DIM); } 
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  f44f5180          MOV      r1,#0x1000
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZN6Cortex11SwitchStackEPjj ; Cortex::SwitchStack(unsigned*, unsigned)
00000e  bd10              POP      {r4,pc}
;;;319    
                          ENDP


                          AREA ||area_number.53||, COMGROUP=_ZN6Cortex11SwitchStackILj4096EEEvRAT__j, LINKORDER=||t._ZN6Cortex11SwitchStackILj4096EEEvRAT__j||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN6Cortex11SwitchStackILj4096EEEvRAT__j||
                          DCD      0x00000001

                          AREA ||i._ZN6Cortex3ISBEv||, COMGROUP=_ZN6Cortex3ISBEv, CODE, READONLY, ALIGN=1

                  _ZN6Cortex3ISBEv PROC ; Cortex::ISB()
;;;123      FORCE_INLINE void DSB() noexcept { SCHEDULE_BARRIER(); __dsb(0xF); SCHEDULE_BARRIER(); }
;;;124      FORCE_INLINE void ISB() noexcept { SCHEDULE_BARRIER(); __isb(0xF); SCHEDULE_BARRIER(); }
000000  bf00              NOP      
000002  bf00              NOP      
000004  f3bf8f6f          ISB      
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  4770              BX       lr
;;;125    
                          ENDP


                          AREA ||area_number.60||, COMGROUP=_ZN6Cortex3ISBEv, LINKORDER=||i._ZN6Cortex3ISBEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6Cortex3ISBEv||
                          DCD      0x00000001

                          AREA ||i._Z15ARM_WSR_baseprij||, COMGROUP=_Z15ARM_WSR_baseprij, CODE, READONLY, ALIGN=1

                  _Z15ARM_WSR_baseprij PROC ; ARM_WSR_basepri(unsigned)
;;;41     DEFINE_ARM_RSR(basepri)
;;;42     DEFINE_ARM_WSR(basepri)
000000  f3808811          MSR      BASEPRI,r0
000004  4770              BX       lr
;;;43     DEFINE_ARM_RSR(primask)
                          ENDP


                          AREA ||area_number.67||, COMGROUP=_Z15ARM_WSR_baseprij, LINKORDER=||i._Z15ARM_WSR_baseprij||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z15ARM_WSR_baseprij||
                          DCD      0x00000001

                          AREA ||t._ZN6Atomic6ModifyIjLNS_9BinOpTypeE5EEET_RVS2_S2_||, COMGROUP=_ZN6Atomic6ModifyIjLNS_9BinOpTypeE5EEET_RVS2_S2_, CODE, READONLY, ALIGN=1

                  _ZN6Atomic6ModifyIjLNS_9BinOpTypeE5EEET_RVS2_S2_ PROC ; T1 Atomic::Modify<unsigned, (Atomic::BinOpType)5>(volatile T1&, T1)
;;;54       template<typename TYPE, BinOpType OP> 
;;;55       inline TYPE Modify(TYPE volatile & data, TYPE const operand) noexcept
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;56       {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;57         TYPE result;
;;;58         
;;;59         do 
000008  bf00              NOP      
                  |L73.10|
;;;60         {
;;;61           result = Cortex::LoadLinked(data);
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       _ZN6Cortex10LoadLinkedIjEET_RVKS1_ ; T1 Cortex::LoadLinked<unsigned>(const volatile T1&)
000010  4604              MOV      r4,r0
;;;62         } while ( Cortex::SaveConditional(data, BinOp<TYPE, OP>::Calc(result, operand)) );
000012  4639              MOV      r1,r7
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       _ZN6Atomic5BinOpIjLNS_9BinOpTypeE5EE4CalcEjj ; Atomic::BinOp<unsigned, (Atomic::BinOpType)5>::Calc(unsigned, unsigned)
00001a  4680              MOV      r8,r0
00001c  4641              MOV      r1,r8
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       _ZN6Cortex15SaveConditionalIjEEbRVT_S1_ ; bool Cortex::SaveConditional<unsigned>(volatile T1&, T1)
000024  2800              CMP      r0,#0
000026  d1f0              BNE      |L73.10|
;;;63         
;;;64         return result;
000028  4625              MOV      r5,r4
00002a  4628              MOV      r0,r5
;;;65       }
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;66     
                          ENDP


                          AREA ||area_number.74||, COMGROUP=_ZN6Atomic6ModifyIjLNS_9BinOpTypeE5EEET_RVS2_S2_, LINKORDER=||t._ZN6Atomic6ModifyIjLNS_9BinOpTypeE5EEET_RVS2_S2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.74||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN6Atomic6ModifyIjLNS_9BinOpTypeE5EEET_RVS2_S2_||
                          DCD      0x00000001

                          AREA ||t._ZN6Cortex10LoadLinkedIjEET_RVKS1_||, COMGROUP=_ZN6Cortex10LoadLinkedIjEET_RVKS1_, CODE, READONLY, ALIGN=1

                  _ZN6Cortex10LoadLinkedIjEET_RVKS1_ PROC ; T1 Cortex::LoadLinked<unsigned>(const volatile T1&)
;;;247      template<typename TYPE>
;;;248      FORCE_INLINE TYPE LoadLinked(TYPE const volatile & data) noexcept { DMB(); return ArmExclusive<sizeof(TYPE)>::LdrEx(data); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  f7fffffe          BL       _ZN6Cortex3DMBEv ; Cortex::DMB()
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj ; Cortex::ArmExclusive<(unsigned)4>::LdrEx(const volatile unsigned&)
00000e  4605              MOV      r5,r0
000010  4628              MOV      r0,r5
000012  bd70              POP      {r4-r6,pc}
;;;249      
                          ENDP


                          AREA ||area_number.81||, COMGROUP=_ZN6Cortex10LoadLinkedIjEET_RVKS1_, LINKORDER=||t._ZN6Cortex10LoadLinkedIjEET_RVKS1_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.81||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN6Cortex10LoadLinkedIjEET_RVKS1_||
                          DCD      0x00000001

                          AREA ||t._ZN6Atomic5BinOpIjLNS_9BinOpTypeE5EE4CalcEjj||, COMGROUP=_ZN6Atomic5BinOpIjLNS_9BinOpTypeE5EE4CalcEjj, CODE, READONLY, ALIGN=1

                  _ZN6Atomic5BinOpIjLNS_9BinOpTypeE5EE4CalcEjj PROC ; Atomic::BinOp<unsigned, (Atomic::BinOpType)5>::Calc(unsigned, unsigned)
;;;41       template<typename TYPE> struct BinOp<TYPE, BinOpType::opAnd> { static constexpr TYPE Calc(TYPE const l, TYPE const r) noexcept { return l & r; } };
;;;42       template<typename TYPE> struct BinOp<TYPE, BinOpType::opOrr> { static constexpr TYPE Calc(TYPE const l, TYPE const r) noexcept { return l | r; } };
000000  4602              MOV      r2,r0
000002  ea420001          ORR      r0,r2,r1
000006  4770              BX       lr
;;;43       
                          ENDP


                          AREA ||area_number.88||, COMGROUP=_ZN6Atomic5BinOpIjLNS_9BinOpTypeE5EE4CalcEjj, LINKORDER=||t._ZN6Atomic5BinOpIjLNS_9BinOpTypeE5EE4CalcEjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.88||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN6Atomic5BinOpIjLNS_9BinOpTypeE5EE4CalcEjj||
                          DCD      0x00000001

                          AREA ||t._ZN6Cortex15SaveConditionalIjEEbRVT_S1_||, COMGROUP=_ZN6Cortex15SaveConditionalIjEEbRVT_S1_, CODE, READONLY, ALIGN=1

                  _ZN6Cortex15SaveConditionalIjEEbRVT_S1_ PROC ; bool Cortex::SaveConditional<unsigned>(volatile T1&, T1)
;;;258      template<typename TYPE>
;;;259      FORCE_INLINE bool SaveConditional(TYPE volatile & data, TYPE const value) noexcept
000000  b570              PUSH     {r4-r6,lr}
;;;260      {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;261        if ( ArmExclusive<sizeof(TYPE)>::StrEx(data, value) )
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj ; Cortex::ArmExclusive<(unsigned)4>::StrEx(volatile unsigned&, unsigned)
00000e  b108              CBZ      r0,|L94.20|
;;;262          return true;
000010  2001              MOVS     r0,#1
                  |L94.18|
;;;263    
;;;264        DSB();
;;;265          
;;;266        return false;
;;;267      }
000012  bd70              POP      {r4-r6,pc}
                  |L94.20|
000014  f7fffffe          BL       _ZN6Cortex3DSBEv ; Cortex::DSB()
000018  2000              MOVS     r0,#0                 ;266
00001a  e7fa              B        |L94.18|
;;;268      
                          ENDP


                          AREA ||area_number.95||, COMGROUP=_ZN6Cortex15SaveConditionalIjEEbRVT_S1_, LINKORDER=||t._ZN6Cortex15SaveConditionalIjEEbRVT_S1_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.95||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN6Cortex15SaveConditionalIjEEbRVT_S1_||
                          DCD      0x00000001

                          AREA ||i._ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj||, COMGROUP=_ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj, CODE, READONLY, ALIGN=1

                  _ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj PROC ; Cortex::ArmExclusive<(unsigned)4>::LdrEx(const volatile unsigned&)
;;;67         
;;;68         static WORD LdrEx(WORD const volatile & data)                   noexcept { return _LdrExW(&data); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       _LdrExW
00000a  4605              MOV      r5,r0
00000c  4628              MOV      r0,r5
00000e  bd70              POP      {r4-r6,pc}
;;;69         static bool StrEx(WORD       volatile & data, WORD const value) noexcept { return _StrExW(&data, value) != 0U; }
                          ENDP


                          AREA ||area_number.102||, COMGROUP=_ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj, LINKORDER=||i._ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.102||, ||.ARM.exidx||
                          REQUIRE __aeabi_unwind_cpp_pr0
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj||
                          DCD      0x00000000
                          RELOC 42, ||.extab._ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj||

                          AREA ||.ARM.extab||, COMGROUP=_ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj, DATA, READONLY, ALIGN=2

                          REQUIRE __cxa_call_unexpected
                  ||.extab._ZN6Cortex12ArmExclusiveILj4EE5LdrExERVKj||
                          DCD      0x80aab0b0
000004  0002000b          DCW      0x0002,0x000b
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||i._ZN6Cortex3DMBEv||, COMGROUP=_ZN6Cortex3DMBEv, CODE, READONLY, ALIGN=1

                  _ZN6Cortex3DMBEv PROC ; Cortex::DMB()
;;;121    
;;;122      FORCE_INLINE void DMB() noexcept { SCHEDULE_BARRIER(); __dmb(0xF); SCHEDULE_BARRIER(); }  
000000  bf00              NOP      
000002  bf00              NOP      
000004  f3bf8f5f          DMB      
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  4770              BX       lr
;;;123      FORCE_INLINE void DSB() noexcept { SCHEDULE_BARRIER(); __dsb(0xF); SCHEDULE_BARRIER(); }
                          ENDP


                          AREA ||area_number.110||, COMGROUP=_ZN6Cortex3DMBEv, LINKORDER=||i._ZN6Cortex3DMBEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.110||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6Cortex3DMBEv||
                          DCD      0x00000001

                          AREA ||i._ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj||, COMGROUP=_ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj, CODE, READONLY, ALIGN=1

                  _ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj PROC ; Cortex::ArmExclusive<(unsigned)4>::StrEx(volatile unsigned&, unsigned)
;;;68         static WORD LdrEx(WORD const volatile & data)                   noexcept { return _LdrExW(&data); }
;;;69         static bool StrEx(WORD       volatile & data, WORD const value) noexcept { return _StrExW(&data, value) != 0U; }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _StrExW
00000e  b108              CBZ      r0,|L116.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L116.22|
                  |L116.20|
000014  2000              MOVS     r0,#0
                  |L116.22|
000016  4606              MOV      r6,r0
000018  4630              MOV      r0,r6
00001a  bd70              POP      {r4-r6,pc}
;;;70     
                          ENDP


                          AREA ||area_number.117||, COMGROUP=_ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj, LINKORDER=||i._ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.117||, ||.ARM.exidx||
                          REQUIRE __aeabi_unwind_cpp_pr0
                          DCD      0x00000000
                          RELOC 42, ||i._ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj||
                          DCD      0x00000000
                          RELOC 42, ||.extab._ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj||

                          AREA ||area_number.118||, COMGROUP=_ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.118||, ||.ARM.extab||
                          REQUIRE __cxa_call_unexpected
                  ||.extab._ZN6Cortex12ArmExclusiveILj4EE5StrExERVjj||
                          DCD      0x80aab0b0
000004  0002000f          DCW      0x0002,0x000f
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||i.__ARM_common_noexcept_landing||, COMGROUP=__ARM_common_noexcept_landing, CODE, READONLY, ALIGN=1

                  __ARM_common_noexcept_landing PROC
000000  f7ffbffe          B.W      __cxa_call_terminate
                          ENDP


                          AREA ||area_number.125||, COMGROUP=__ARM_common_noexcept_landing, LINKORDER=||i.__ARM_common_noexcept_landing||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.125||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__ARM_common_noexcept_landing||
                          DCD      0x00000001
